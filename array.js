/*Как получить последний элемент из произвольного массива?
У нас есть массив goods. Сколько в нем элементов – не знаем, но можем прочитать из goods.length.
Напишите код для получения последнего элемента goods.*/

var goods = ['apple', 'pineapple'];
var lastItem = goods[goods.length - 1];

/*Как добавить элемент в конец произвольного массива?
У нас есть массив goods. Напишите код для добавления в его конец значения «Компьютер».*/

var goods = ['apple', 'pineapple'];
goods.push('Компьютер');

/*Задача из 5 шагов-строк:

    Создайте массив styles с элементами «Джаз», «Блюз».
    Добавьте в конец значение «Рок-н-Ролл»
    Замените предпоследнее значение с конца на «Классика». Код замены предпоследнего значения должен работать для массивов любой длины.
    Удалите первое значение массива и выведите его alert.
    Добавьте в начало значения «Рэп» и «Регги».

Массив в результате каждого шага:

Джаз, Блюз
Джаз, Блюз, Рок-н-Ролл
Джаз, Классика, Рок-н-Ролл
Классика, Рок-н-Ролл
Рэп, Регги, Классика, Рок-н-Ролл*/

var styles = ['Джаз', 'Блюз'];
styles.push('Рок-н-Ролл');
styles[styles.length - 2] = 'Классика';
alert(styles.shift());
styles.unshift('Рэп', 'Рэгги');

/*Напишите код для вывода alert случайного значения из массива:
var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];

P.S. Код для генерации случайного целого от min to max включительно:
var rand = min + Math.floor(Math.random() * (max + 1 - min));*/

var arr = ['Яблоко', 'Апельсин', 'Груша', 'Лимон'];
var rand = Math.floor(Math.random() * (arr.length));
alert(arr[rand]);

/*Напишите код, который:

    Запрашивает по очереди значения при помощи prompt и сохраняет их в массиве.
    Заканчивает ввод, как только посетитель введёт пустую строку, не число или нажмёт «Отмена».
    При этом ноль 0 не должен заканчивать ввод, это разрешённое число.
    Выводит сумму всех значений массива
*/

var o = [];
while (true) {
    var question = prompt('Введите значение', 0);
    if (question === '' || question === null || isNaN(question)) {
        break;
    }
    o.push(+question);
}

var sum = 0;
for (var i = 0; i < o.length; i++) {
    sum += o[i];
}

alert(sum);

/*Создайте функцию find(arr, value), которая ищет в массиве arr значение value и возвращает его номер, если найдено, или -1, если не найдено.
Например:

arr = ["test", 2, 1.5, false];

find(arr, "test"); // 0
find(arr, 2); // 1
find(arr, 1.5); // 2

find(arr, 0); // -1*/

arr = ["test", 2, 1.5, false];

function find(arr, value) {
    if (value) {
        return arr.indexOf(value);
    } else {
        return -1;
    }
}

/*Создайте функцию filterRange(arr, a, b), которая принимает массив чисел arr и возвращает новый массив,
который содержит только числа из arr из диапазона от a до b.
То есть, проверка имеет вид a ≤ arr[i] ≤ b. Функция не должна менять arr.
Пример работы:

var arr = [5, 4, 3, 8, 0];

var filtered = filterRange(arr, 3, 5);
// теперь filtered = [5, 4, 3]
// arr не изменился*/
var results = [];

function filterRange(arr, a, b) {
    var results = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] >= a && arr[i] <= b) {
            results.push(arr[i]);
        }
    }
    return results;
}

var arr = [5, 4, 3, 8, 0];
var filtered = filterRange(arr, 3, 5);
alert(filtered);

/*Целое число, большее 1, называется простым, если оно не делится нацело ни на какое другое, кроме себя и 1.
Древний алгоритм «Решето Эратосфена» для поиска всех простых чисел до n выглядит так:

    Создать список последовательных чисел от 2 до n: 2, 3, 4, ..., n.
    Пусть p=2, это первое простое число.
    Зачеркнуть все последующие числа в списке с разницей в p, т.е. 2*p, 3*p, 4*p и т.д. В случае p=2 это будут 4,6,8....
    Поменять значение p на первое не зачеркнутое число после p.
    Повторить шаги 3-4 пока p2 < n.
    Все оставшиеся не зачеркнутыми числа – простые.

Посмотрите также анимацию алгоритма.
Реализуйте «Решето Эратосфена» в JavaScript, используя массив.  
Найдите все простые числа до 100 и выведите их сумму.*/

var a = [];

for (var i = 2; i < 100; i++) {
    a[i] = true;
}

var p = 2;

do {
    for (i = 2 * p; i < 100; i += p) {
        a[i] = false;
    }

    for (i = p + 1; i < 100; i++) {
        if (a[i]) break;
    }

    p = i;
} while (p * p < 100);

var sum = 0;
for (i = 0; i < a.length; i++) {
    if (a[i]) {
        sum += i;
    }
}

alert(sum);

/*На входе массив чисел, например: arr = [1, -2, 3, 4, -9, 6].
Задача – найти непрерывный подмассив arr, сумма элементов которого максимальна.
Ваша функция должна возвращать только эту сумму.
Например:                 
getMaxSubSum([-1, 2, 3, -9]) = 5 (сумма выделенных)
getMaxSubSum([2, -1, 2, 3, -9]) = 6
getMaxSubSum([-1, 2, 3, -9, 11]) = 11
getMaxSubSum([-2, -1, 1, 2]) = 3
getMaxSubSum([100, -9, 2, -3, 5]) = 100
getMaxSubSum([1, 2, 3]) = 6 (неотрицательные - берем всех)

Если все элементы отрицательные, то не берём ни одного элемента и считаем сумму равной нулю:
getMaxSubSum([-1, -2, -3]) = 0

Постарайтесь придумать решение, которое работает за O(n2), а лучше за O(n) операций.*/

function getMaxSubSum(arr) {
    var maxSum = 0;

    for (var i = 0; i < arr.length; i++) {
        var sum = 0;
        for (var b = i; b < arr.length; b++) {
            sum += arr[b];
            maxSum = Math.max(maxSum, sum);
        }
    }

    return maxSum;
}

getMaxSubSum([-1, 2, 3, -9]) = 5;
getMaxSubSum([2, -1, 2, 3, -9]);
getMaxSubSum([-1, 2, 3, -9, 11]);
getMaxSubSum([-2, -1, 1, 2]);
getMaxSubSum([100, -9, 2, -3, 5]);
getMaxSubSum([1, 2, 3]);